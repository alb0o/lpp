#pragma paradigm hybrid

// Test generic call syntax
// foo<int>(x) should transpile to foo(x)

// Generic identity function
fn identity<T>(value: T) -> T {
    return value;
}

// Generic max function
fn maximum<T>(a: T, b: T) -> T {
    if (a > b) {
        return a;
    }
    return b;
}

// Generic container
fn create_pair<T, U>(first: T, second: U) -> string {
    return "pair created";
}

fn main() -> void {
    // Test calls with explicit type parameters
    let x = identity<int>(42);
    let y = identity<string>("hello");
    let z = maximum<float>(3.14, 2.71);

    let pair = create_pair<int, string>(1, "one");

    print("Generic calls work!");
}
